<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lachlan Gibson - foo.bar</title>
    <link rel="stylesheet" href="../styles/foobar.css" />
    <!-- google font -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap"
      rel="stylesheet"
    />

    <!-- MathJax for latex maths -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
  </head>

  <body>
    <header></header>
    <main>
      <a href="/">Home</a>
      <article>
        <h1>Google FooBar</h1>
        <p>
          I completed Google's
          <a href="https://foobar.withgoogle.com/" target="_blank">FooBar</a>
          challenge during April 2023. This involved solving a series of
          mathematical and coding problems using Python 2.7 (or Java). The
          challenge included 5 levels of increasing difficulty with 1-3 tasks
          per level. Here I summarise the tasks and explain how I solved each
          one.
        </p>

        <div class="table-of-contents toc-layer1">
          <a href="#sec-challenge1">Challenge 1</a>
          <a href="#sec-challenge2">Challenge 2</a>
          <a href="#sec-challenge3">Challenge 3</a>
          <a href="#sec-challenge4">Challenge 4</a>
          <a href="#sec-challenge5">Challenge 5</a>
        </div>

        <section class="foobar-challenge" id="sec-challenge1">
          <h2>Challenge 1</h2>
          <div class="table-of-contents toc-layer2">
            <a href="#sec-task-1">Re-ID</a>
          </div>
          <p>
            The first level contained only a single task, titled "Re-ID", which
            involved efficiently generating prime numbers. A task summary,
            adapted from the original challenge instructions, is given below.
          </p>
          <section class="foobar-task" id="sec-task-1">
            <div class="foobar-task-description">
              Re-ID<br />
              =====<br />
              <br />
              Write a function solution(n) which takes in the starting index n
              of a string of all primes, "2357111317192329...", and returns the
              next five digits in the string. For example, if n is 3 then their
              ID number will be "71113". The value of n will always be between 0
              and 10000.<br />
              <br />
              -- Test cases --<br />
              Input : solution(0)<br />
              Output: 23571<br />
              <br />
              Input : solution(3)<br />
              Output: 71113
            </div>

            <p>
              If the string of prime numbers is known, then the solution is
              trivially given by returning the five digits starting at index
              \(n\). Therefore, I solved this problem by defining a function
              that firstly generated this string of primes. This function works
              by checking the primality of all integers from \(2\) to
              \(m=20+\lfloor n \ln 10 \rfloor \). This choice of \(m\) ensures
              that the resulting string of primes is at least \(n+5\) characters
              long, without too much excessive computation.<br />
              <br />
              This is a result of the prime number theorem which gives an
              asymptotic expression for the prime counting function,
              \[\pi(m)\sim{m\over \ln m},\] which counts the number of prime
              numbers \(\leqslant m\). The maximum number of digits each prime
              can have is \(\log m\) (base 10). Therefore, having \(n+5<
              \pi(m)\log m\) should ensure the resulting string is long enough
              when \(n\) is large. This condition is satisfied by \[m=20+\lfloor
              n \ln 10 \rfloor ,\] which I checked empirically worked for when
              \(n\) is low.<br />
              <br />
              Each integer is considered prime if no previously identified prime
              numbers divide it. This involves checking all previously
              identified prime numbers less than or equal to the square-root of
              the current candidate number (there is no point checking factors
              higher than the square-root because they all pair with divisors
              less than the square-root). Once the list of prime numbers is
              generated then the integers are converted to strings before being
              joined into a single string.
            </p>
            <!--http://tohtml.com/python/-->
            <pre
              class="code_syntax"
              style="color: #d1d1d1; background: #000000"
            ><span class="line_wrapper"><span style="color:#e66170; font-weight:bold; ">def</span> solution<span style="color:#d2cd86; ">(</span>n<span style="color:#d2cd86; ">)</span><span style="color:#d2cd86; ">:</span></span>
<span class="line_wrapper">    <span style="color:#e66170; font-weight:bold; ">def</span> generate_prime_string<span style="color:#d2cd86; ">(</span>n<span style="color:#d2cd86; ">)</span><span style="color:#d2cd86; ">:</span></span>
<span class="line_wrapper">        <span style="color:#9999a9; ">"""</span></span>
<span class="line_wrapper"><span style="color:#9999a9; ">        Returns a string of consecutive prime numbers with a target</span></span>
<span class="line_wrapper"><span style="color:#9999a9; ">        length of at least n + 5.</span></span>
<span class="line_wrapper"><span style="color:#9999a9; ">        """</span></span>
<span class="line_wrapper">        prime_list <span style="color:#d2cd86; ">=</span> <span style="color:#d2cd86; ">[</span><span style="color:#d2cd86; ">]</span></span>
<span class="line_wrapper">        <span style="color:#9999a9; "># prime density * log(n) approximates the length of the string</span></span>
<span class="line_wrapper">        max_num <span style="color:#d2cd86; ">=</span> <span style="color:#00a800; ">20</span> <span style="color:#00dddd; ">+</span> <span style="color:#e66170; font-weight:bold; ">int</span><span style="color:#d2cd86; ">(</span><span style="color:#009f00; ">2.303</span><span style="color:#00dddd; ">*</span>n<span style="color:#d2cd86; ">)</span></span>
<span class="line_wrapper">        <span style="color:#e66170; font-weight:bold; ">for</span> num_check <span style="color:#e66170; font-weight:bold; ">in</span> <span style="color:#e66170; font-weight:bold; ">range</span><span style="color:#d2cd86; ">(</span><span style="color:#00a800; ">2</span><span style="color:#d2cd86; ">,</span> max_num <span style="color:#00dddd; ">+</span> <span style="color:#00a800; ">1</span><span style="color:#d2cd86; ">)</span><span style="color:#d2cd86; ">:</span></span>
<span class="line_wrapper">            prime <span style="color:#d2cd86; ">=</span> True</span>
<span class="line_wrapper">            <span style="color:#9999a9; "># no need to check larger factors</span></span>
<span class="line_wrapper">            max_factor <span style="color:#d2cd86; ">=</span> <span style="color:#e66170; font-weight:bold; ">int</span><span style="color:#d2cd86; ">(</span>num_check<span style="color:#00dddd; ">**</span><span style="color:#009f00; ">0.5</span> <span style="color:#00dddd; ">+</span> <span style="color:#00a800; ">1</span><span style="color:#d2cd86; ">)</span></span>
<span class="line_wrapper">            <span style="color:#e66170; font-weight:bold; ">for</span> p <span style="color:#e66170; font-weight:bold; ">in</span> prime_list<span style="color:#d2cd86; ">:</span></span>
<span class="line_wrapper">                <span style="color:#e66170; font-weight:bold; ">if</span> num_check <span style="color:#00dddd; ">%</span> p <span style="color:#00dddd; ">==</span> <span style="color:#00a800; ">0</span><span style="color:#d2cd86; ">:</span></span>
<span class="line_wrapper">                    prime <span style="color:#d2cd86; ">=</span> False</span>
<span class="line_wrapper">                    <span style="color:#e66170; font-weight:bold; ">break</span></span>
<span class="line_wrapper">                <span style="color:#e66170; font-weight:bold; ">elif</span> p <span style="color:#00dddd; ">&gt;</span> max_factor<span style="color:#d2cd86; ">:</span></span>
<span class="line_wrapper">                    <span style="color:#e66170; font-weight:bold; ">break</span></span>
<span class="line_wrapper">            <span style="color:#e66170; font-weight:bold; ">if</span> prime<span style="color:#d2cd86; ">:</span></span>
<span class="line_wrapper">                prime_list<span style="color:#d2cd86; ">.</span>append<span style="color:#d2cd86; ">(</span>num_check<span style="color:#d2cd86; ">)</span></span>
<span class="line_wrapper">        <span style="color:#e66170; font-weight:bold; ">return</span> <span style="color:#00c4c4; ">""</span><span style="color:#d2cd86; ">.</span>join<span style="color:#d2cd86; ">(</span><span style="color:#d2cd86; ">[</span><span style="color:#e66170; font-weight:bold; ">str</span><span style="color:#d2cd86; ">(</span>p<span style="color:#d2cd86; ">)</span> <span style="color:#e66170; font-weight:bold; ">for</span> p <span style="color:#e66170; font-weight:bold; ">in</span> prime_list<span style="color:#d2cd86; ">]</span><span style="color:#d2cd86; ">)</span></span>
<span class="line_wrapper">    <span style="color:#e66170; font-weight:bold; ">return</span> generate_prime_string<span style="color:#d2cd86; ">(</span>n<span style="color:#d2cd86; ">)</span><span style="color:#d2cd86; ">[</span>n<span style="color:#d2cd86; ">:</span>n<span style="color:#00dddd; ">+</span><span style="color:#00a800; ">5</span><span style="color:#d2cd86; ">]</span></span>
<span class="line_wrapper"></span></pre>
          </section>
        </section>
        <section class="foobar-challenge" id="sec-challenge2">
          <h2>Challenge 2</h2>
          <div class="table-of-contents toc-layer2">
            <a href="#sec-task-2">Please Pass the Coded Messages</a>
            <a href="#sec-task-3">Bunny Worker Locations</a>
          </div>
          <section class="foobar-task" id="sec-task-2">
            <div class="foobar-task-description">
              Please Pass the Coded Messages<br />
              ==============================<br />
              <br />
              You have L, a list containing some digits (0 to 9). Write a
              function solution(L) which finds the largest number that can be
              made from some or all of these digits and is divisible by 3. If it
              is not possible to make such a number, return 0 as the solution. L
              will contain anywhere from 1 to 9 digits. The same digit may
              appear multiple times in the list, but each element in the list
              may only be used once.<br />
              <br />
              -- Test cases -- <br />
              Input : solution([3, 1, 4, 1])<br />
              Output: 4311<br />
              <br />
              Input : solution([3, 1, 4, 1, 5, 9])<br />
              Output: 94311<br />
            </div>
          </section>
          <section class="foobar-task" id="sec-task-3">
            <div class="foobar-task-description">
              Bunny Worker Locations<br />
              ======================<br />

              <br />
              In a triangular grid of values each cell can be represented as
              points (x, y), with x being the distance from the vertical wall,
              and y being the height from the ground. For example, the value at
              (1, 1) is 1, the value at (3, 2) is 9, and the value at (2,3) is
              8. This pattern of numbering continues indefinitely.<br />
              <br />
              | 7<br />
              | 4 8<br />
              | 2 5 9<br />
              | 1 3 6 10<br />
              <br />
              Write a function solution(x, y) which returns the grid value at
              the location (x, y). Both x and y will be at least 1 and no
              greater than 100,000. Since the values can be very large, return
              your solution as a string representation of the number.<br />
              <br />
              -- Test cases --<br />
              Input : solution(5, 10)<br />
              Output: 96<br />
              <br />
              Input : solution(3, 2)<br />
              Output: 9
            </div>
          </section>
        </section>
        <section class="foobar-challenge" id="sec-challenge3">
          <h2>Challenge 3</h2>
          <div class="table-of-contents toc-layer2">
            <a href="#sec-task-4">Prepare the Bunnies' Escape</a>
            <a href="#sec-task-5">The Grandest Staircase Of Them All</a>
            <a href="#sec-task-6">Fuel Injection Perfection</a>
          </div>
          <section class="foobar-task" id="sec-task-4">
            <div class="foobar-task-description">
              Prepare the Bunnies' Escape<br />
              ===========================<br />
              <br />
              Write a function solution(map) that generates the length of the
              shortest path along a rectangular grid from (0,0) to (w-1,h-1),
              where w is the grid width, h is the grid height and the map is
              represented as a matrix of 0s and 1s, where 0s are passable space
              and 1s are impassable walls. The path may remove up to one wall.
              The path length is the total number of nodes you pass through,
              counting both the entrance and exit nodes. The starting and ending
              positions are always passable (0). The map will always be
              solvable, though you may or may not need to remove a wall. The
              height and width of the map can be from 2 to 20. Moves can only be
              made in cardinal directions; no diagonal moves are allowed.<br />
              <br />
              -- Test cases --<br />
              Input : solution([[0, 1, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0], [1, 1,
              1, 0]])<br />
              Output: 7<br />
              <br />
              Input : solution([[0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0], [0, 0,
              0, 0, 0, 0], [0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 0, 0, 0,
              0, 0]])<br />
              Output: 11
            </div>
          </section>
          <section class="foobar-task" id="sec-task-5">
            <div class="foobar-task-description">
              The Grandest Staircase Of Them All<br />
              ==================================<br />
              <br />
              Write a function called solution(n) that takes a positive integer
              n and returns the number of different staircases that can be built
              from exactly n bricks. n will always be between 3 and 200
              (inclusive). Each type of staircase should consist of 2 or more
              steps with no two steps being at the same height. All steps must
              contain at least one brick. A step's height is classified as the
              total amount of bricks that make up that step.<br />
              <br />
              For example, when n = 3, you have only 1 choice of how to build
              the staircase, with the first step having a height of 2 and the
              second step having a height of 1: (# indicates a brick)<br />
              <br />
              #<br />
              ##<br />
              21<br />
              <br />
              When n = 4, you still only have 1 staircase choice:<br />
              <br />
              #<br />
              #<br />
              ##<br />
              31<br />
              <br />
              But when n = 5, there are two ways you can build a staircase from
              the given bricks. The two staircases can have heights (4, 1) or
              (3, 2), as shown below:<br />
              <br />
              #<br />
              #<br />
              #<br />
              ##<br />
              41<br />
              <br />
              #<br />
              ##<br />
              ##<br />
              32<br />
              <br />
              -- Test cases --<br />
              Input : solution(200)<br />
              Output: 487067745<br />
              <br />
              Input : solution(3)<br />
              Output: 1
            </div>
          </section>
          <section class="foobar-task" id="sec-task-6">
            <div class="foobar-task-description">
              Fuel Injection Perfection<br />
              =========================<br />
              <br />
              Write a function called solution(n) which takes a positive integer
              as a string and returns the minimum number of operations needed to
              transform n to 1. Quantities will not exceed 309 digits long. The
              three allowed operations are +1, -1 and /2 (if the quantity is
              even).<br />
              <br />
              For example:<br />
              n = 4 requires two operations: 4 -> 2 -> 1<br />
              n = 15 requires five operations: 15 -> 16 -> 8 -> 4 -> 2 -> 1<br />
              <br />
              -- Test cases --<br />
              Input : solution('15')<br />
              Output: 5<br />
              <br />
              Input : solution('4')<br />
              Output: 2
            </div>
          </section>
        </section>
        <section class="foobar-challenge" id="sec-challenge4">
          <h2>Challenge 4</h2>
          <div class="table-of-contents toc-layer2">
            <a href="#sec-task-7">Bringing a Gun to a Trainer Fight</a>
            <a href="#sec-task-8">Free the Bunny Workers</a>
          </div>
          <section class="foobar-task" id="sec-task-7">
            <div class="foobar-task-description">
              Bringing a Gun to a Trainer Fight<br />
              =================================<br />
              <br />
              Write a function solution(dimensions, your_position,
              trainer_position, distance) that gives an array of 2 integers of
              the width and height of the room, an array of 2 integers of your x
              and y coordinates in the room, an array of 2 integers of the
              trainer's x and y coordinates in the room, and returns an integer
              of the number of distinct directions that you can fire to hit the
              elite trainer, given the maximum distance that the beam can
              travel.<br />
              <br />
              The room has integer dimensions [1 < x_dim <= 1250, 1 < y_dim <=
              1250]. You and the elite trainer are both positioned on the
              integer lattice at different distinct positions (x, y) inside the
              room such that [0 < x < x_dim, 0 < y < y_dim]. Finally, the
              maximum distance that the beam can travel before becoming harmless
              will be given as an integer 1 < distance <= 10000.<br />
              <br />
              For example, if you and the elite trainer were positioned in a
              room with dimensions [3, 2], your_position [1, 1],
              trainer_position [2, 1], and a maximum shot distance of 4, you
              could shoot in seven different directions to hit the elite trainer
              (given as vector bearings from your location): [1, 0], [1, 2], [1,
              -2], [3, 2], [3, -2], [-3, 2], and [-3, -2]. As specific examples,
              the shot at bearing [1, 0] is the straight line horizontal shot of
              distance 1, the shot at bearing [-3, -2] bounces off the left wall
              and then the bottom wall before hitting the elite trainer with a
              total shot distance of sqrt(13), and the shot at bearing [1, 2]
              bounces off just the top wall before hitting the elite trainer
              with a total shot distance of sqrt(5).<br />
              <br />
              -- Test cases --<br />
              Input : solution([3,2], [1,1], [2,1], 4)<br />
              Output: 7<br />
              <br />
              Input : solution([300,275], [150,150], [185,100], 500)<br />
              Output: 9
            </div>
          </section>
          <section class="foobar-task" id="sec-task-8">
            <div class="foobar-task-description">
              Free the Bunny Workers<br />
              ======================<br />
              <br />
              Given the number of bunnies available and the number of locks
              required to open a work room, write a function solution(num_buns,
              num_required) which returns a specification of how to distribute
              the keys such that any num_required bunnies can open the locks,
              but no group of (num_required - 1) bunnies can.<br />
              <br />
              Each lock is numbered starting from 0. The keys are numbered the
              same as the lock they open (so for a duplicate key, the number
              will repeat, since it opens the same lock). For a given bunny, the
              keys they get is represented as a sorted list of the numbers for
              the keys. To cover all of the bunnies, the final solution is
              represented by a sorted list of each individual bunny's list of
              keys. Find the lexicographically least such key distribution -
              that is, the first bunny should have keys sequentially starting
              from 0.<br />
              <br />
              num_buns will always be between 1 and 9, and num_required will
              always be between 0 and 9 (both inclusive). For example, if you
              had 3 bunnies and required only 1 of them to open the cell, you
              would give each bunny the same key such that any of the 3 of them
              would be able to open it, like so:<br />
              <br />
              [<br />
              [0],<br />
              [0],<br />
              [0],<br />
              ]<br />
              <br />
              If you had 2 bunnies and required both of them to open the cell,
              they would receive different keys (otherwise they wouldn't both
              actually be required), and your solution would be as follows:<br />
              <br />
              [<br />
              [0],<br />
              [1],<br />
              ]<br />
              <br />
              Finally, if you had 3 bunnies and required 2 of them to open the
              cell, then any 2 of the 3 bunnies should have all of the keys
              necessary to open the cell, but no single bunny would be able to
              do it. Thus, the solution would be:<br />
              <br />
              [<br />
              [0, 1],<br />
              [0, 2],<br />
              [1, 2],<br />
              ]<br />
              <br />
              -- Test cases --<br />
              Input : solution(4, 4)<br />
              Output: [[0], [1], [2], [3]]<br />
              <br />
              Input : solution(5, 3)<br />
              Output: [[0, 1, 2, 3, 4, 5], [0, 1, 2, 6, 7, 8], [0, 3, 4, 6, 7,
              9], [1, 3, 5, 6, 8, 9], [2, 4, 5, 7, 8, 9]]<br />
              <br />
              Input : solution(2, 1)<br />
              Output: [[0], [0]]
            </div>
          </section>
        </section>
        <section class="foobar-challenge" id="sec-challenge5">
          <h2>Challenge 5</h2>
          <div class="table-of-contents toc-layer2">
            <a href="#sec-task-9">Dodge the Lasers!</a>
          </div>
          <section class="foobar-task" id="sec-task-9">
            <div class="foobar-task-description">
              Dodge the Lasers!<br />
              =================<br />
              <br />
              Write a function solution(str_n) which, given the string
              representation of an integer n, returns the sum of
              (floor(1*sqrt(2)) + floor(2*sqrt(2)) + ... + floor(n*sqrt(2))) as
              a string. That is, for every number i in the range 1 to n, it adds
              up all of the integer portions of i*sqrt(2).<br />
              <br />
              For example, if str_n was "5", the solution would be calculated
              as<br />
              floor(1*sqrt(2)) +<br />
              floor(2*sqrt(2)) +<br />
              floor(3*sqrt(2)) +<br />
              floor(4*sqrt(2)) +<br />
              floor(5*sqrt(2))<br />
              = 1+2+4+5+7 = 19<br />
              so the function would return "19".<br />
              <br />
              str_n will be a positive integer between 1 and 10^100, inclusive.
              Since n can be very large (up to 101 digits!), using just sqrt(2)
              and a loop won't work. Sometimes, it's easier to take a step back
              and concentrate not on what you have in front of you, but on what
              you don't.<br />
              <br />
              -- Test cases --<br />
              Input : solution('77')<br />
              Output: 4208<br />
              <br />
              Input : solution('5')<br />
              Output: 19
            </div>
          </section>
        </section>
      </article>
    </main>
    <footer></footer>
  </body>
</html>
